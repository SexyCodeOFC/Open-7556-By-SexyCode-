#include "stdafx.h"
#include "HookImpl.h"

typedef struct _HEADER
{
	short		  Size;
	char		  KeyWord;
	char		  CheckSum;
	short		  Type;
	short		  ID;
	unsigned int  ClientTick;
} HEADER, * PHEADER;

unsigned char pKeyWord[512] = { // 7.xx keys
	0x84, 0x87, 0x37, 0xd7, 0xea, 0x79, 0x91, 0x7d, 0x4b, 0x4b, 0x85, 0x7d, 0x87, 0x81, 0x91, 0x7c, 0x0f, 0x73, 0x91, 0x91, 0x87, 0x7d, 0x0d, 0x7d, 0x86, 0x8f, 0x73, 0x0f, 0xe1, 0xdd, 0x85, 0x7d,
	0x05, 0x7d, 0x85, 0x83, 0x87, 0x9c, 0x85, 0x33, 0x0d, 0xe2, 0x87, 0x19, 0x0f, 0x79, 0x85, 0x86, 0x37, 0x7d, 0xd7, 0xdd, 0xe9, 0x7d, 0xd7, 0x7d, 0x85, 0x79, 0x05, 0x7d, 0x0f, 0xe1, 0x87, 0x7e,
	0x23, 0x87, 0xf5, 0x79, 0x5f, 0xe3, 0x4b, 0x83, 0xa3, 0xa2, 0xae, 0x0e, 0x14, 0x7d, 0xde, 0x7e, 0x85, 0x7a, 0x85, 0xaf, 0xcd, 0x7d, 0x87, 0xa5, 0x87, 0x7d, 0xe1, 0x7d, 0x88, 0x7d, 0x15, 0x91,
	0x23, 0x7d, 0x87, 0x7c, 0x0d, 0x7a, 0x85, 0x87, 0x17, 0x7c, 0x85, 0x7d, 0xac, 0x80, 0xbb, 0x79, 0x84, 0x9b, 0x5b, 0xa5, 0xd7, 0x8f, 0x05, 0x0f, 0x85, 0x7e, 0x85, 0x80, 0x85, 0x98, 0xf5, 0x9d,
	0xa3, 0x1a, 0x0d, 0x19, 0x87, 0x7c, 0x85, 0x7d, 0x84, 0x7d, 0x85, 0x7e, 0xe7, 0x97, 0x0d, 0x0f, 0x85, 0x7b, 0xea, 0x7d, 0xad, 0x80, 0xad, 0x7d, 0xb7, 0xaf, 0x0d, 0x7d, 0xe9, 0x3d, 0x85, 0x7d,
	0x87, 0xb7, 0x23, 0x7d, 0xe7, 0xb7, 0xa3, 0x0c, 0x87, 0x7e, 0x85, 0xa5, 0x7d, 0x76, 0x35, 0xb9, 0x0d, 0x6f, 0x23, 0x7d, 0x87, 0x9b, 0x85, 0x0c, 0xe1, 0xa1, 0x0d, 0x7f, 0x87, 0x7d, 0x84, 0x7a,
	0x84, 0x7b, 0xe1, 0x86, 0xe8, 0x6f, 0xd1, 0x79, 0x85, 0x19, 0x53, 0x95, 0xc3, 0x47, 0x19, 0x7d, 0xe7, 0x0c, 0x37, 0x7c, 0x23, 0x7d, 0x85, 0x7d, 0x4b, 0x79, 0x21, 0xa5, 0x87, 0x7d, 0x19, 0x7d,
	0x0d, 0x7d, 0x15, 0x91, 0x23, 0x7d, 0x87, 0x7c, 0x85, 0x7a, 0x85, 0xaf, 0xcd, 0x7d, 0x87, 0x7d, 0xe9, 0x3d, 0x85, 0x7d, 0x15, 0x79, 0x85, 0x7d, 0xc1, 0x7b, 0xea, 0x7d, 0xb7, 0x7d, 0x85, 0x7d,
	0x85, 0x7d, 0x0d, 0x7d, 0xe9, 0x73, 0x85, 0x79, 0x05, 0x7d, 0xd7, 0x7d, 0x85, 0xe1, 0xb9, 0xe1, 0x0f, 0x65, 0x85, 0x86, 0x2d, 0x7d, 0xd7, 0xdd, 0xa3, 0x8e, 0xe6, 0x7d, 0xde, 0x7e, 0xae, 0x0e,
	0x0f, 0xe1, 0x89, 0x7e, 0x23, 0x7d, 0xf5, 0x79, 0x23, 0xe1, 0x4b, 0x83, 0x0c, 0x0f, 0x85, 0x7b, 0x85, 0x7e, 0x8f, 0x80, 0x85, 0x98, 0xf5, 0x7a, 0x85, 0x1a, 0x0d, 0xe1, 0x0f, 0x7c, 0x89, 0x0c,
	0x85, 0x0b, 0x23, 0x69, 0x87, 0x7b, 0x23, 0x0c, 0x1f, 0xb7, 0x21, 0x7a, 0x88, 0x7e, 0x8f, 0xa5, 0x7d, 0x80, 0xb7, 0xb9, 0x18, 0xbf, 0x4b, 0x19, 0x85, 0xa5, 0x91, 0x80, 0x87, 0x81, 0x87, 0x7c,
	0x0f, 0x73, 0x91, 0x91, 0x84, 0x87, 0x37, 0xd7, 0x86, 0x79, 0xe1, 0xdd, 0x85, 0x7a, 0x73, 0x9b, 0x05, 0x7d, 0x0d, 0x83, 0x87, 0x9c, 0x85, 0x33, 0x87, 0x7d, 0x85, 0x0f, 0x87, 0x7d, 0x0d, 0x7d,
	0xf6, 0x7e, 0x87, 0x7d, 0x88, 0x19, 0x89, 0xf5, 0xd1, 0xdd, 0x85, 0x7d, 0x8b, 0xc3, 0xea, 0x7a, 0xd7, 0xb0, 0x0d, 0x7d, 0x87, 0xa5, 0x87, 0x7c, 0x73, 0x7e, 0x7d, 0x86, 0x87, 0x23, 0x85, 0x10,
	0xd7, 0xdf, 0xed, 0xa5, 0xe1, 0x7a, 0x85, 0x23, 0xea, 0x7e, 0x85, 0x98, 0xad, 0x79, 0x86, 0x7d, 0x85, 0x7d, 0xd7, 0x7d, 0xe1, 0x7a, 0xf5, 0x7d, 0x85, 0xb0, 0x2b, 0x37, 0xe1, 0x7a, 0x87, 0x79,
	0x84, 0x7d, 0x73, 0x73, 0x87, 0x7d, 0x23, 0x7d, 0xe9, 0x7d, 0x85, 0x7e, 0x02, 0x7d, 0xdd, 0x2d, 0x87, 0x79, 0xe7, 0x79, 0xad, 0x7c, 0x23, 0xda, 0x87, 0x0d, 0x0d, 0x7b, 0xe7, 0x79, 0x9b, 0x7d,
	0xd7, 0x8f, 0x05, 0x7d, 0x0d, 0x34, 0x8f, 0x7d, 0xad, 0x87, 0xe9, 0x7c, 0x85, 0x80, 0x85, 0x79, 0x8a, 0xc3, 0xe7, 0xa5, 0xe8, 0x6b, 0x0d, 0x74, 0x10, 0x73, 0x33, 0x17, 0x0d, 0x37, 0x21, 0x19
};

BYTE* HookImpl::HKD_ReadMessage(int instModule, int* unkParam1, int* unkParam2)
{
	BYTE* packetBuffer = NULL;

	// Chama função original
	__asm
	{
		PUSH DWORD PTR SS : [unkParam2]
		PUSH DWORD PTR SS : [unkParam1]
		MOV ECX, instModule
		PUSH ECX
		CALL HookImpl::ReadMessage

		MOV packetBuffer, EAX
	}

	if (!packetBuffer)
		return packetBuffer;

	return packetBuffer;
}

int HookImpl::HKD_AddMessage(int Socket, MSG_STANDARD* OldMsg, int MsgSize)
{
	int ret = 0;

	char* NewMsg = (char*)malloc(MsgSize);

	if (NewMsg == NULL)
		return 0;

	memcpy(NewMsg, OldMsg, MsgSize);

	// Compara o size do pacote no header e passado por parametro
	if (*(unsigned short*)NewMsg != (unsigned short)MsgSize)
	{
		*(unsigned short*)NewMsg = (unsigned short)MsgSize;
	}

	// Chama a função original
	__asm
	{
		PUSH DWORD PTR SS : [MsgSize]
		PUSH DWORD PTR SS : [NewMsg]
		MOV ECX, Socket
		PUSH ECX
		CALL HookImpl::AddMessage

		MOV ret, EAX
	}

	free(NewMsg);

	return ret;
}

BOOL HookImpl::AddMessage(CPSock* thisPtr, char* pMsg, int Size)
{
	char temp[256];
	MSG_STANDARD* std = (MSG_STANDARD*)pMsg;

	if (thisPtr->nSendPosition + Size >= 0x20000)
	{
		return FALSE;
	}

	// check socket valid
	if (thisPtr->Sock <= 0)
	{
		return FALSE;
	}

	unsigned char iKeyWord = rand() % 256;
	unsigned char KeyWord = pKeyWord[iKeyWord * 2];
	unsigned char CheckSum = 0;
	std->Size = Size;
	std->KeyWord = iKeyWord;
	std->CheckSum = CheckSum;
	std->ClientTick = timeGetTime();

	unsigned char Sum1 = 0;
	unsigned char Sum2 = 0;
	int			  pos = KeyWord;

	for (int i = 4; i < Size; i++, pos++)
	{
		Sum1 += pMsg[i];

		int rst = pos % 256;

		unsigned char Trans = pKeyWord[rst * 2 + 1];

		int mod = i & 0x3;

		if (mod == 0)
			thisPtr->pSendBuffer[thisPtr->nSendPosition + i] = pMsg[i] + (Trans << 1);

		if (mod == 1)
			thisPtr->pSendBuffer[thisPtr->nSendPosition + i] = pMsg[i] - (Trans >> 3);

		if (mod == 2)
			thisPtr->pSendBuffer[thisPtr->nSendPosition + i] = pMsg[i] + (Trans << 2);

		if (mod == 3)
			thisPtr->pSendBuffer[thisPtr->nSendPosition + i] = pMsg[i] - (Trans >> 5);

		Sum2 += thisPtr->pSendBuffer[thisPtr->nSendPosition + i];
	}

	CheckSum = Sum2 - Sum1;
	std->CheckSum = CheckSum;

	memcpy(thisPtr->pSendBuffer + thisPtr->nSendPosition, pMsg, 4);

	thisPtr->nSendPosition = thisPtr->nSendPosition + Size;

	return TRUE;
}

char* HookImpl::ReadMessage(CPSock* thisPtr, int* ErrorCode, int* ErrorType)
{
	*ErrorCode = 0;

	if (thisPtr->nProcPosition >= thisPtr->nRecvPosition)
	{
		thisPtr->nRecvPosition = 0;
		thisPtr->nProcPosition = 0;

		return 0;
	}

	//  Init packet authentication
	if (thisPtr->Init == 0)
	{
		if (thisPtr->nRecvPosition - thisPtr->nProcPosition < 4)
			return 0;

		int InitCode = *((unsigned int*)(thisPtr->pRecvBuffer + thisPtr->nProcPosition));

		if (InitCode != 0x1F11F311)
		{
			*ErrorCode = 2;
			*ErrorType = InitCode;

			return 0;
		}

		thisPtr->Init = 1;
		thisPtr->nProcPosition += 4;
	}

	//	Check received message is larger than HEADER
	if (thisPtr->nRecvPosition - thisPtr->nProcPosition < sizeof(HEADER))
		return 0;

	//	Check full message arrived
	unsigned short	Size = *((unsigned short*)(thisPtr->pRecvBuffer + thisPtr->nProcPosition));
	unsigned char	iKeyWord = *((unsigned char*)(thisPtr->pRecvBuffer + thisPtr->nProcPosition + 2));
	unsigned char	KeyWord = pKeyWord[iKeyWord * 2];
	unsigned char	CheckSum = *((unsigned char*)(thisPtr->pRecvBuffer + thisPtr->nProcPosition + 3));
	unsigned int	SockType = *((unsigned int*)(thisPtr->pRecvBuffer + thisPtr->nProcPosition + 4));
	unsigned int	SockID = *((unsigned int*)(thisPtr->pRecvBuffer + thisPtr->nProcPosition + 6));

	if (Size > 8192 || Size < sizeof(HEADER))
	{
		thisPtr->nRecvPosition = 0;
		thisPtr->nProcPosition = 0;

		*ErrorCode = 2;
		*ErrorType = Size;

		return 0;
	}

	unsigned int Rest = thisPtr->nRecvPosition - thisPtr->nProcPosition;

	if (Size > Rest)
		return 0;

	//	Get message
	char* pMsg = &(thisPtr->pRecvBuffer[thisPtr->nProcPosition]);

	thisPtr->nProcPosition = thisPtr->nProcPosition + Size;

	if (thisPtr->nRecvPosition <= thisPtr->nProcPosition)
	{
		thisPtr->nRecvPosition = 0;
		thisPtr->nProcPosition = 0;
	}

	// Compare check_sum in packet
	unsigned char Sum1 = 0;
	unsigned char Sum2 = 0;

	int	pos = KeyWord;

	for (int i = 4; i < Size; i++, pos++)
	{
		int rst = pos % 256;

		Sum2 += pMsg[i];

		unsigned char Trans = pKeyWord[rst * 2 + 1];

		int mod = i & 0x3;

		if (mod == 0)
			pMsg[i] = pMsg[i] - (Trans << 1);

		if (mod == 1)
			pMsg[i] = pMsg[i] + (Trans >> 3);

		if (mod == 2)
			pMsg[i] = pMsg[i] - (Trans << 2);

		if (mod == 3)
			pMsg[i] = pMsg[i] + (Trans >> 5);

		Sum1 += pMsg[i];
	}

	unsigned char Sum = Sum2 - Sum1;

	// return packet, even check_sum not match
	if (Sum != CheckSum)
	{
		*ErrorCode = 1;
		*ErrorType = Size;

		return pMsg;
	}

	return pMsg;
}


bool HookImpl::HKD_PacketControlRECV(const int32_t code)
{
	printf("RECV PACKET DBSRV: Code %X \n", code);
	return true;
}
